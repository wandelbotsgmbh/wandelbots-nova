from nova import api
from nova.actions.base import Action
from nova.actions.motions import Motion
from nova.exceptions import InconsistentCollisionScenes


def compare_collision_setups(setup1: api.models.CollisionSetup, setup2: api.models.CollisionSetup):
    """Return True if two pydantic CollisionSetup models are equal by value.

    Uses model_dump in json mode with exclude_unset/none to avoid differences caused
    by default/unset fields or None values.
    """
    dump1 = setup1.model_dump_json(exclude_unset=True, exclude_none=True)
    dump2 = setup2.model_dump_json(exclude_unset=True, exclude_none=True)
    return dump1 == dump2


def validate_collision_setups(actions: list[Action]) -> list[api.models.CollisionSetup]:
    """
    RAE V1 APIs provide two ways of planning actions.
    Collition free planning and collision checked planning.
    As the names suggest, collision free planning produces a joint trajectory with which the collision is avoided.
    But collision check planning checks for collision and if there is one, it will return an error.


    The action list python sdk takes from the user has a variety of types.
    There can be a variety of actions in the list.
    1. Collision free motions
    2. Normal motions
    3. Waits
    4. Write actions -> this is a special write on the path supported by the API


    This function checks that a given set of actions contains valid collision scenes data.
    It is assumed that the action list provided here is a sub-batch generated by the split_actions_into_batches function.
    """
    motion_count = len([action for action in actions if isinstance(action, Motion)])
    collision_setups = [
        action.collision_setup
        for action in actions
        if isinstance(action, Motion) and action.collision_setup is not None
    ]

    if len(collision_setups) != 0 and len(collision_setups) != motion_count:
        raise InconsistentCollisionScenes(
            "Only some of the actions have collision scene. Either specify it for all or none."
        )

    # If a collision scene is provided, the same should be provided for all the collision scene
    if len(collision_setups) > 1:
        first_setup = collision_setups[0]
        if not all(compare_collision_setups(first_setup, setup) for setup in collision_setups[1:]):
            raise InconsistentCollisionScenes(
                "All actions must use the same collision scene but some are different"
            )

    return collision_setups


def motion_group_setup_from_motion_group_description(
    motion_group_description: api.models.MotionGroupDescription,
    tcp_name: str | None = None,
    payload: api.models.Payload | None = None,
) -> api.models.MotionGroupSetup:
    collision_setup = get_safety_collision_setup_from_motion_group_description(
        motion_group_description=motion_group_description, tcp_name=tcp_name
    )
    # For the time being it is assumed that the auto limits are always present
    # We also assume that the motion player in RAE will scale corretly if the
    # planned trajectory is played back with different limits (due to a different robot mode)
    # than the one used for planning
    assert motion_group_description.operation_limits.auto_limits is not None
    limits = motion_group_description.operation_limits.auto_limits
    tcps = motion_group_description.tcps
    tcp_offset = tcps[tcp_name].pose if tcp_name is not None and tcps is not None else None
    return api.models.MotionGroupSetup(
        motion_group_model=motion_group_description.motion_group_model,
        cycle_time=motion_group_description.cycle_time or 8,
        mounting=motion_group_description.mounting,
        global_limits=limits,
        tcp_offset=tcp_offset,
        payload=payload,
        collision_setups=api.models.CollisionSetups({"safety": collision_setup}),
    )


def get_safety_collision_setup_from_motion_group_description(
    motion_group_description: api.models.MotionGroupDescription, tcp_name: str | None
) -> api.models.CollisionSetup:
    tool_colliders = (
        motion_group_description.safety_tool_colliders.get(tcp_name)
        if motion_group_description.safety_tool_colliders is not None and tcp_name is not None
        else None
    )
    tool = api.models.Tool(tool_colliders.root) if tool_colliders is not None else None
    link_chain = (
        api.models.LinkChain(
            [api.models.Link(link.root) for link in motion_group_description.safety_link_colliders]
        )
        if motion_group_description.safety_link_colliders
        else None
    )
    return api.models.CollisionSetup(
        colliders=motion_group_description.safety_zones,
        link_chain=link_chain,
        tool=tool,
        self_collision_detection=False,  # explicitly set here until we have a better understanding
    )


def get_joint_position_limits_from_motion_group_setup(
    motion_group_setup: api.models.MotionGroupSetup,
) -> api.models.JointPositionLimits | None:
    """Extract joint position limits from motion group description, if available."""
    if motion_group_setup.global_limits is None or motion_group_setup.global_limits.joints is None:
        return None

    # TODO: does optional mean no limit applied for that joint?
    # will joint.position is not None cause issues by skipping joints without limits?
    joint_limit_range_list = [
        joint.position
        for joint in motion_group_setup.global_limits.joints
        if joint.position is not None
    ]
    return api.models.JointPositionLimits(root=joint_limit_range_list)
